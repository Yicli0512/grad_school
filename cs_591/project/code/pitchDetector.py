###Problem 3: For this problem, I want you to write a program pitchDetector.py###       which asks the user for the name of a file, and a timestamp (e.g., 3.0 secs)###       and prints out the frequency in Hz found at that point in the file.###       You should first filter the signal using your filter from problem one,###       and use the technique of auto-correlation as presented in class and as###       found in the tutorial on pitch detection.##Steps:##Read in the signal into an array x[]##  y = lowPassFilter(x) ##   let z be an array of 1000 doubles which will store the correlations calculated for each potential period t##  For t in range(11, 1000):                              # t is width of period in samples; this gives a range of frequencies from 44.1 to 4000 ##        z[t] = autocorrelation of y, starting at the timestamp and going forward 0.25 seconds (feel free to play around with this)##   Identify frequency by using peak-picking; using some suitable threshold parameters, identify first location in z where there is a peak which##         is (i) a peak, i.e., x[i-1] < x[i] > x[i+1] (ii) a global maximum, i.e., x[i] > G, and##         (iii) a local maximum, i.e., x[i] > (L + mean(x[i-M] .. x[i+M])) for some M.##import myfilterimport numpy as np##import pylab as plimport arrayimport contextlibimport waveimport math##from constant import *def readwav(fname):    with contextlib.closing(wave.open(fname)) as f:        params = f.getparams()        frames = f.readframes(params[3])    return array.array("h", frames), params##def drawGraph(signal):####    x=[]####    for i in range(len(signal)):####        x.append(i)######    y = myfilter.lowPassFilter(signal)####    y2 = signal########    #for i in range(len(signal)):####    #   pl.plot(x[i],y[i],'.',color = [1,0,0])####    pl.title('Low Pass Filter\n')####    pl.xlabel('Time')####    pl.ylabel('Amplitude')####    pl.plot(x,y2,color = [0,1,0],label="Origin")####    pl.plot(x,y,color = [1,0,0])########    pl.show()# show the plot on the screendef peak_picking(X,M,G,L):##    print "peak_picking"    for i in range(M,len(X)-1):        # print("X[i]",X[i])        if(X[i-1] < X[i] > X[i+1]):            if(X[i] > G and X[i] > (L + np.mean(X[i-M:i+M]))):                # print "pick ",i                return i  #return the first auto correlation no.        return 0    #return 0 may cause devider error       def auto_correlation(X,Y):    X = np.array(X)    Y = np.array(Y)    #calculate mu and sigma for the two signals    xmean = np.mean(X)    ymean = np.mean(Y)    xstd = np.std(X)    ystd = np.std(Y)    return np.mean(((X - xmean)*(Y - ymean))/(xstd*ystd))def pitch(data,time_stamp,time_interval):    deltaTime = time_interval  #Get a segment of the signal(6seconds)     start = int(float(time_stamp)* 44100) #calculate the start no. of the sample    length = int(deltaTime*44100)    # signal = myfilter.lowPassFilter(data)    signal = data    Z = [0]*1000  #the list of corelation values, initialized it with 0    period = 0    # t is width of period in samples; this gives a range of frequencies from 44.1 to 4000    for t in range(11,1000):        Z[t] = auto_correlation(signal[start:start+length],signal[start+t:start+t+length])    result = peak_picking(Z,40,0.2,0.1)  #I set M=40,G=0.5,L=0.1    # print result    # print(signal[start+result])    # print Z[result]    # print"The pitch frequency for ",   time_stamp , " is :", 44100.0/result    if result > 0:        return 44100.0/result    else:        return float('inf')if __name__ == '__main__':    infileName = raw_input("Enter the name of the input .wav file: ")    data, params = readwav(infileName)    start_time = float(raw_input("Please Enter Satrt Time Stamp: "))    time_interval = float(raw_input("Please Enter Interval: "))    lengthOfFile = params[3]/44100.0  # Get length of time    time_stamp = start_time    timePoint = []    pitches = []    while time_stamp + time_interval < lengthOfFile:##        print 'Calculating the pitch frequency at time: '+str(time_stamp) + '...'        p = pitch(data,time_stamp,time_interval)##        print p        if p < float('inf'):            timePoint.append(time_stamp)            pitches.append(p)        else:            timePoint.append(time_stamp)            pitches.append(0)        time_stamp += time_interval        #pl.plot(time_stamp,p,'o')##    pl.plot(timePoint,pitches)####    pl.show()